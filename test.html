<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,width=device-width,user-scalable=no" />


<style>


:root {
    --main-row-size: 24;
    --main-font-size: 12;
}

body {
    overflow: hidden;
    width: 100%;
    font-family: 'Roboto', sans-serif;
    font-size: var(--main-font-size);
}

div.data {
  position: absolute;
  padding: 0 5px;
  overflow: hidden;
  height: 100%;
}

div.header {
  position: absolute;
  width: 25%;
  padding: 0 5px;
  overflow: hidden;
}

div.headers {
  position: absolute;
  width: 100%;
  border: 1px black;
  border-style: solid;
  border-radius: 5px;
  height: var(--main-row-size);
}

div.datarow {
  position: absolute;
  width: 100%;
  border: 1px rgba(0, 0, 0, 0.51) solid;
  border-radius: 5px;
  background: white;
  height: var(--main-row-size);
  overflow: hidden;
}

div.table-contrainer {
    position: absolute;
}

div[cell_type="pos"] {
    color: black;
    left: 0%;
    width: 10%;
}

div[cell_type="title"] {
    color: black;
    left: 10%;
    width: 40%;
}

div[cell_type="author"] {
    color: black;
    left: 50%;
    width: 25%;
}

div[cell_type="streams"] {
    color: black;
    left: 75%;
    width: 25%;
}

div[is_new="enter"] {
    background-color: rgb(255, 255, 96);
    
}

div.table {
  position:relative;
  left: 0px;
  width: 80%;
}

svg.triangle {
    position: absolute;
    /* width: 20px;
    height: 20px; */
    top: 2px;
    left: 20px;
}
</style>

<body style="margin: 0; background: #222222">
  <div id="container" style="width:100%; margin: 0px;">                                   
    <div id="left" style="float:left; width:75%; margin: 0px;"> 
    </div>                     
    <div id="right" style="float:right; width:25%; margin: 0px;"> 
      <input id="song_input" hidden="true"/>
      <button id="go_button" hidden="true">Show infos</button>
      <div id="controls" />
    </div>                   
  </div>   
  
</body>



<link rel="stylesheet" type="text/css" href="music.css">
<link rel="stylesheet" href="complete/awesomplete.css" />
<script src="complete/awesomplete.js" async></script>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://d3js.org/topojson.v1.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="utils.js"></script>
<script src="https://s3.amazonaws.com/stitch-sdks/js/library/stable/stitch.min.js"></script>
<link rel="stylesheet" href="css/streamgraph.css"></script>
<script src="js/streamgraph.js"></script>
<link rel="stylesheet" href="css/ranklegend.css"></script>
<script src="js/ranklegend.js"></script>
<script src="js/worldmap.js"></script>
<!--<script src="stitch.js"></script>-->

<script>


//-----------------------------------

let timer;

let leftDiv = document.getElementById("left");

let width = leftDiv.clientWidth;
let height = window.innerHeight ;

/*
map.append("use")
    .attr("class", "fill")
    .attr("xlink:href", "#sphere");*/
/*
map.append("rect")
    .attr("width", "100%")
    .attr("height", "100%")
    .attr("fill", d3.color("#00FFFFFF"));*/


let countryTooltip = d3.select("body").append("div") 
    .attr("class", "tooltip")       
    .style("opacity", 0);

let streamGraph;
let timelapseData;


const client = new stitch.StitchClient('dataviz-xeqhx');
const db = client.service('mongodb', 'mongodb-atlas').db('music');


const continents = ["Europe","North America","Latin America"/*"South America", "Central America"*/, "Asia & Oceania"/* "Asia","Oceania"*/]

const NorthAmerica = ["us","ca"];
const CentralAmerica = ["do","pa","mx","cr","gt","sv","hn"];
const SouthAmerica = ["ar","br","ec","bo","uy","cl","py","pe","co"];
const LatinAmerica = CentralAmerica.concat(SouthAmerica);
const Asia = ["jp","ph","id","my","sg","hk","tw"];
const Europe = ["se","hu","pl","be","gr","es","fi","at","ch","sk","gb","pt","is","de","fr","it","nl","cz","cy","dk","ie","ee","lt","no","tr","lv"];
const Oceania = ["au","nz"];
const AsiaOceania = Asia.concat(Oceania);

const continentColors = ["#3366cc", "#dc3912", "#ff9900", "#109618", "#990099", "#0099c6"];
const continentColorsDict = {
  "Europe": continentColors[0],
  "North America": continentColors[1],
  "Latin America": continentColors[2],
  "Asia & Oceania": continentColors[3]
}


let CountryContinentDict = {};
for(let i = 0; i < NorthAmerica.length; i++) {
  CountryContinentDict[NorthAmerica[i]] = "North America"
}
for(let i = 0; i < CentralAmerica.length; i++) {
  CountryContinentDict[CentralAmerica[i]] = "Central America"
}
for(let i = 0; i < SouthAmerica.length; i++) {
  CountryContinentDict[SouthAmerica[i]] = "South America"
} 
for(let i = 0; i < LatinAmerica.length; i++) {
  CountryContinentDict[LatinAmerica[i]] = "Latin America"
} 
for(let i = 0; i < Europe.length; i++) {
  CountryContinentDict[Europe[i]] = "Europe"
}
for(let i = 0; i < Asia.length; i++) {
  CountryContinentDict[Asia[i]] = "Asia"
}
for(let i = 0; i < Oceania.length; i++) {
  CountryContinentDict[Oceania[i]] = "Oceania"
}
for(let i = 0; i < AsiaOceania.length; i++) {
  CountryContinentDict[AsiaOceania[i]] = "Asia & Oceania"
}


let colorScale = d3.scaleLinear()
    .domain([0,1])
    //.interpolate(d3.interpolateHcl)
    .interpolate(d3.interpolateRgb)
    .range([d3.rgb('#FF4444'), d3.rgb("#444444")]);

let colorScales = {
}

for(let continent in continentColorsDict) {
  colorScales[continent] =  d3.scaleLinear()
                              .domain([0,0.1,1])
                              //.interpolate(d3.interpolateHcl)
                              .interpolate(d3.interpolateRgb)
                              .range([d3.rgb(continentColorsDict[continent]), d3.interpolateRgb(d3.rgb(continentColorsDict[continent]),"#444444")(0.5), d3.rgb("#444444")]);
}


let svg = d3.select("#left").append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("transform", "translate(" + 0 + "," + 0 + ")");

let worldMap = new WorldMap(width * 0.8, height * 0.9, svg, continentColorsDict, CountryContinentDict);

let rankPage = d3.select("#left").append("div")
    .attr("class", "table-contrainer")
    .style("width", width + "px")
    .style("height", height + "px")
/*
    .attr("class", "node")
    .attr("width", width)
    .attr("height", height)
    .attr("x", 0)
    .attr("y", 0)
    .style("width", width + "px")
    .style("height", height + "px");*/


let navigationMap = true;

let navigation = svg.append("image")
    .attr("xlink:href","img/semi.svg")
    .attr("width", width/15)
    .attr("height", width/30)

navigation
  .attr("transform", "translate(" + ((width/2)-(navigation.node().getBoundingClientRect().width / 2)) + "," + (height - navigation.node().getBoundingClientRect().height) + ")");

function getNavigationTransform() {
    if(navigationMap) {
      return "translate(" + ((width/2)-(navigation.node().getBoundingClientRect().width / 2)) + "," + (height - navigation.node().getBoundingClientRect().height) + ") rotate(0)";
    } else {
      return "translate(" + ((width/2)+(navigation.node().getBoundingClientRect().width / 2)) + "," +  navigation.node().getBoundingClientRect().height + ") rotate(180)"
    }
}

navigation.on("click", function() {

    if(navigationMap) { 

      navigationMap = false

      navigation.transition()
        .attr("transform", getNavigationTransform())
        .duration(1000) 
        .delay(0)    

      worldMap.map.transition()
        .attr("transform", "translate(0, " + (-height) + ")")
        .duration(1000) 
        .delay(0)    

        let streamGraph_height = 50;

        if(streamGraph) {
            streamGraph_height = streamGraph.streamGraph.node().getBoundingClientRect().height;
        }

      rankPage.transition()
        .style("top", (navigation.node().getBoundingClientRect().height + streamGraph_height + 20) + "px")
        .duration(1000) 
        .delay(0)    

    } 
    else {
      navigationMap = true

      navigation.transition()        
        .attr("transform", getNavigationTransform())
        .duration(1200) 
        .delay(0)   

      worldMap.map.transition()
        .attr("transform", "translate(0, " + 0 + ")")
        .duration(1200) 
        .delay(0)     

      rankPage.transition()
        .style("top", (height + 10) + "px")
        .duration(1000) 
        .delay(0)   
    }


    streamGraphTransition(1000);
  })

function streamGraphTransition(delay) {

  if(streamGraph) {   
    if(navigationMap) {
      streamGraph.streamGraph.transition()
        .attr("transform", "translate(" + ((width/2)-(streamGraph.streamGraph.node().getBoundingClientRect().width / 2)) + "," + (height - navigation.node().getBoundingClientRect().height - streamGraph.streamGraph.node().getBoundingClientRect().height - 10) + ")")
        .duration(delay) 
        .delay(0)   
    }
    else {      
      streamGraph.streamGraph.transition()
        .attr("transform", "translate(" + /*40*/(width-streamGraph.streamGraph.node().getBoundingClientRect().width) + "," + (navigation.node().getBoundingClientRect().height + 10) + ")")
        .duration(delay) 
        .delay(0)   
    }
  }
}

const lowestDate = new Date("2017-01-01T12:00:00.000Z");
let midDate = new Date("2017-07-01T00:00:00.000Z");
let selectedSongID;

let countries;
let spotify_countries;
let streamsDict = {};
let spotify_dict;
let world;

function linspace(start, end, n) {
    var out = [];
    var delta = (end - start) / (n - 1);

    var i = 0;
    while(i < (n - 1)) {
        out.push(start + (i * delta));
        i++;
    }

    out.push(end);
    return out;
}



let getAllDocuments = function(collection, query, callback, documents, projection) {
    //console.log(query)
    //console.log(projection)
    collection.find(query,{project: projection, limit:10000}).then(items => {
      documents = documents.concat(items);
      
      if(items.length >= 10000) {
        let last_id = documents[documents.length - 1]["_id"];
        console.log(last_id);
        query["_id"] = {"$gt":last_id}
        getAllDocuments(collection, query, callback, documents, projection);
      }
      else {
        callback(documents);
      }
    })
  }


let songListCallback = function(list) {
  // Map songs to label and value to be displayed in the autocomplete input
  songsList = list.map(function(x) {
    return {
      label: x["Track Name"] + " - " + x["Artist"], 
      value: { text: x["Track Name"], id: x["id"] }
    }
  });


  // Set the autocomplete input
  let input = document.getElementById("song_input");
  new Awesomplete(input, {
    list: songsList, 
    replace: function(item) {
      selectedSongID = item.value.id;
      this.input.value = item.value.text;
    }
  });

  // Display the autocomplete input
  input.hidden = false;

  let button = document.getElementById("go_button");
  button.hidden = false;
  button.onclick = function() {    
    if(selectedSongID && spotify_countries) {

      let songEntriesCallback = function(timeLine) {

        timeLine = timeLine.filter(x => x.r != 'global')

        spotify_countries.forEach(function(d, i) {
          let filtered = timeLine.filter(x => d == x.r);
          let aggregation = filtered.map(x => parseInt(x.s)).reduce(function(a, v) {
              return a + v;
          }, 0)
          streamsDict[d] = aggregation;
        })

        data = timeLine.map(function(x) {
          let region = "Unknown"
          if(x.r in CountryContinentDict) {
            continent = CountryContinentDict[x.r]
          }
          else {
            console.log("Problem with" + x.r)
          }
          return {
            "value": parseInt(x.s),
            "continent": continent,
            "region": x.r,
            "position": x.p,
            "date": x.d.getFullYear() + "/" + ("0" + (x.d.getMonth() + 1)).slice(-2) + "/" + ("0" + x.d.getDate()).slice(-2)
          }
        });

        
        regionsArray = ["Europe","North America","Latin America"/*"South America", "Central America"*/, "Asia & Oceania"/*"Asia","Oceania"*/]
        datesArray = [];

        for(let i = 1; i < 34; i++) {
          let d = new Date(lowestDate.getTime());
          d.setDate(d.getDate() + i*7);
          datesArray.push(d.getFullYear() + "/" + ("0" + (d.getMonth() + 1)).slice(-2) + "/" + ("0" + d.getDate()).slice(-2))
        }

        timelapseData = []
        for(let j = 0; j < datesArray.length; j++) {
          timelapseData.push({"date": datesArray[j]})
        }

        for(let i = 0; i < data.length; i++) {
          let dateIdx = datesArray.indexOf(data[i].date)
          if(dateIdx > -1) {
            timelapseData[dateIdx][data[i].region] = data[i];
          }
        }

        let streamData = []
        for(let j = 0; j < datesArray.length; j++) {
          streamData.push({"date": datesArray[j]})
          for(let i = 0; i < regionsArray.length; i++) {
            streamData[j][regionsArray[i]] = 0
          }
        }

        for(let i = 0; i < data.length; i++) {
          let dateIdx = datesArray.indexOf(data[i].date)
          if(dateIdx > -1) {
            let region = data[i].continent
            streamData[dateIdx][region] += data[i].value
          }
        }

        let format = d3.timeParse("%Y/%m/%d");

        streamData.forEach(function(d) {
          d.date = format(d.date);
        });

        if(streamGraph) {
          streamGraph.setData(streamData);
          streamGraphTransition(1000);
          //histogram = chart(width, height/6, streamData, "palette", svg, histogram);
        }
        else {
          streamGraphListener = {
            buttonPressed(playing) {
              if(playing) {
                startSongTimeLapse(timelapseData, 1);
                console.log("Start timelapse")
              } else {
                stopSongTimeLapse();
                console.log("Stop timelapse")
              }
            }
          }

          streamGraph = new StreamGraph(width, height/6, streamData, svg, streamGraphListener, continentColors, null)
          streamGraph.streamGraph 
            .attr("transform", "translate(" + (-streamGraph.streamGraph.node().getBoundingClientRect().width) + "," + (height - navigation.node().getBoundingClientRect().height - streamGraph.streamGraph.node().getBoundingClientRect().height - 10) + ")")

          streamGraphTransition(1000);

        }

        //resize();


      }

      getAllDocuments(db.collection('entries'), {"id":selectedSongID}, songEntriesCallback, [], {_id: 0, s: 1, r:1, d: 1, p:1})
    }
  }
}

client.login().then(() => getAllDocuments(db.collection('songs'), {}, songListCallback, [], {_id: 0, id: 1, "Track Name": 1, "Artist": 1}))

d3.json("world-110m.json", function(error, w) {

  if (error) throw error;

  world = w;

  countries = topojson.feature(world, world.objects.countries).features
  //let neighbors = topojson.neighbors(world.objects.countries.geometries)


  d3.json("id_dict.json", function(error, dict) {
    countries.forEach(function(d, i) {
      if(dict["" + parseInt(d.id)]) {
        d.name = dict[d.id][1]
        d.alpha2 = dict[d.id][0]
      }

    })

    countries = countries.filter(d => d.alpha2 != "aq")

    d3.json("Datasets/countries.json", function(error, c) {
        spotify_countries = c;
        spotify_dict = {}
        spotify_countries.forEach(function(d, i) {
          spotify_dict[d] = d
        })

        worldMap.drawMap();

    });

  });

});



function startSongTimeLapse(data, speed) {

  let delta = 1000;
  if(speed) {
    delta = 1000 / speed;
  }

  let it = 0;
  let week = 0;

  if(data[week] == undefined) {
    console.log(data)
  }

  timer = setInterval(function() {
    streamGraph.setTimeStamp(it/10.0);
    if(it%10 == 0) {
      let countriesColors = {}
      for(let i = 0; i < spotify_countries.length; i++) {
        let region = spotify_countries[i];
        if(region in data[week]) {
          
          let position = data[week][region].position;
          /*let shade = (100 - position) * 255 / 99.0;
          countriesColors[region] = d3.color(d3.rgb(shade, shade/2, shade/2))*/

          countriesColors[region] = colorScales[CountryContinentDict[region]]((position-1)/99.0)
          //countriesColors[region] = colorScale(position/100.0)
        }
      }
      worldMap.drawMap(countriesColors, delta);

      week += 1;
      if(week == data.length) {
        streamGraph.pause();
        stopSongTimeLapse();
      }
    }
    it++;
  }, delta/10);
  playing = true;
}

function stopSongTimeLapse() {
  clearInterval(timer);
  playing = false;
}


function resize() {
  width = leftDiv.clientWidth;
  height = window.innerHeight ;


  navigation
    .attr("width", width/15)
    .attr("height", width/30)
    .attr("transform", getNavigationTransform());


  d3.select("svg")
    .attr("width", width)
    .attr("height", height)

  worldMap.resize(width, height)

  if(streamGraph) {
    //streamGraph.resize(width/2, height/6)
    streamGraphTransition(0);

    /*let legend = setRankLegend(width/30, height/2, colorScale, svg);
    legend
      .attr("transform", "translate(" + 10 + ", " + (height/2 - legend.node().getBoundingClientRect().height/2) + ")")*/
  }


    
}

function redraw() {
  resize();
  if(streamGraph) {
    streamGraph.resize(width/2, height/6)
  }
}

window.addEventListener("resize", redraw);



d3.select(self.frameElement).style("height", height + "px");

let style = getComputedStyle(document.body);
let row_size = +style.getPropertyValue('--main-row-size') + 4;

let spotify_green = style.getPropertyValue('--main-spotify-green');
let triangle_width = 13;
let triangle_height = 13;
let indexx = 1;
let uniqueID = 0;

// Create a local variable for storing previous data.
let previousData = d3.local();

// Fake data
let tweets = {
"tweets": [
{"pos": 1, "title": "I really love seafood.", "author": "author1", "streams": 456546546},
{"pos": 2, "title": "I take that back, this doesn't taste so good.", "author": "author14", "streams": 546546},
{"pos": 3, "title": "From now on, I'm only eating cheese sandwiches.", "author": "author1324", "streams": 4645},
{"pos": 4, "title": "Great workout!", "author": "author1454", "streams": 2354656},
{"pos": 5, "title": "Spectacular oatmeal!", "author": "6756", "streams": 2354656},
{"pos": 6, "title": "Amazing traffic!", "author": "author145546", "streams": 2354656},
{"pos": 7, "title": "Just got a ticket for texting and driving!", "author": "author12343", "streams": 2354656},
{"pos": 8, "title": "Going to have some boiled eggs.", "author": "author123543", "streams": 2354656},
{"pos": 9, "title": "Maybe practice some gymnastics.", "author": "author134654", "streams": 2354656},
{"pos": 10, "title": "@Roy Let's get lunch", "author": "author13453454", "streams": 567567}
]
}

let tweets3 = {
"tweets": [
{"pos": 1, "title": "Nic", "author": "author1", "streams": 346454},
{"pos": 2, "title": "Bic", "author": "author2", "streams": 4345},
{"pos": 3, "title": "tric", "author": "author14", "streams": 2354656},
{"pos": 4, "title": "pic", "author": "author13454", "streams": 2354656},
{"pos": 5, "title": "Spectacular oatmeal!", "author": "author13454", "streams": 2354656},
{"pos": 6, "title": "Amazing traffic!", "author": "author1356456", "streams": 2354656},
{"pos": 7, "title": "Just got a ticket for texting and driving!", "author": "author1564", "streams": 2354656},
{"pos": 8, "title": "Going to have some boiled eggs.", "author": "author134565465", "streams": 2354656},
{"pos": 9, "title": "Maybe practice some gymnastics.", "author": "author1356546", "streams": 2354656},
{"pos": 10, "title": "@Roy Let's get lunch", "author": "author143564565", "streams": 3453454}
]
}
 
// toplistData - list of json-like elements
function createToplist(toplistData){  
    var keyValues = d3.keys(toplistData[0]);

    let head = rankPage
        .append("div")
        .attr("class", "table")
        .append("div")
        .attr("class", "headers")

    head.selectAll("div.header")
        .data(keyValues)
        .enter()
        .append("div")
        .attr("class", "header")
        .attr("cell_type", (d) => {return d;})
        .html((d) => {return d;});

    d3.select("div.table")
        .selectAll("div.datarow")
        .data(toplistData, (d) => {return d.title;})
        .enter()
        .append("div")
        .attr("class", "datarow")
        .attr("id", function(d) { return uniqueID++; })
        .style("height", row_size + "px")
        .style("top", (d,i) => {return (row_size + ((d.pos-1) * row_size)) + "px";});

    d3.selectAll("div.datarow")
        .selectAll("div.data")
        .data((d) => {return d3.entries(d);})
        .enter()
        .append("div")
        .attr("class", "data")
        .attr("cell_type", (d) => {return d.continent;})
        .html((d) => {return d.value;});

    d3.selectAll("div.datarow")
        .on("click", showDetails);

    d3.selectAll("[cell_type = pos]")
        .each(function(d) { previousData.set(this, d.value) });
}    

function transitionSheet() {
    d3.selectAll("div.datarow")
    .transition()
    .duration(2000)
    .style("top", (d,i) => {return (row_size + ((d.pos-1) * row_size)) + "px";});
    }

function sortSheet() {
    var dataset = d3.selectAll("div.datarow").data();
    dataset.sort((a,b) => {return a.pos > b.pos;
        });

    d3.selectAll("div.datarow")
    .data(dataset, (d) => {return d.title;})
    .transition()
    .duration(2000)
    .style("top", (d,i) => {return (row_size + ((d.pos-1) * row_size));});
    }   

function transformData() {

    // Section that only create fake data for testing purposes
    // Copy to a new variable 
    let tweets2 = JSON.parse(JSON.stringify(tweets3));
    // Add new record
    if (Math.random() > 0.3){
        while(Math.random() > 0.3){
            tweets2.tweets.push({"pos": Math.round(Math.random()*20), "title": "Newone" + indexx++, 
            "author": "author1" + indexx, "streams": Math.round(Math.random()*1000000)});
        }
    }
    
    // Shuffle records
    tweets2.tweets = shuffle(tweets2.tweets);
    //Remove some of the records
    tweets2.tweets = tweets2.tweets.splice(0, tweets2.tweets.length-Math.round(Math.random()*2));
    //New ranking
    let ranking = d3.range(1, tweets2.tweets.length+1)
    // Change position of each record
    tweets2.tweets.forEach( (item, index) => {
        item.pos = ranking[index];
    });

    tweets3 = JSON.parse(JSON.stringify(tweets2));

    updateToplist(tweets2.tweets);

    function updateToplist(newToplist){ 

        // Update those that are in the table
        let rows = d3.select("div.table")
            .selectAll("div.datarow")
            .call(savePreviousData)
            .data(newToplist, (d) => {return d.title;})
            .attr("is_new", "update");
        
        let cells = rows.selectAll("div.data")
            .data((d) => {return d3.entries(d);})
            .html((d) => {return d.value;})
            .attr("is_new", "update");

        rows.transition("sorting")
            .delay((d) => {return 100 + (d.pos/newToplist.length) * 2000;})
            .duration(2000)
            .style("top", (d,i) => {return (row_size + ((d.pos-1) * row_size)) + "px";})
            .on("start", addTriangle);

        // Add new ones
        let enterRows = rows.enter()
            .append("div")
            .attr("class", "datarow")
            .attr("id", function(d) { return uniqueID++; })
            .style("top", (d,i) => {return (row_size + ((d.pos-1) * row_size)) + "px";})
            .style("opacity", 0.0)
            .style("left", "-600px")
            .style("height", row_size + "px")
            .attr("is_new", "enter")
            .on("click", showDetails);

        let enterCells = enterRows.selectAll("div.data")
            .data((d) => {return d3.entries(d);})
            .enter()
            .append("div")
            .attr("class", "data")
            .attr("cell_type", (d) => {return d.continent;})
            .html((d) => {return d.value;});
        
        enterRows.transition("new_rows")
            .ease(d3.easeQuad)
            .delay(3100)
            .duration(1000)
            .style('opacity', 1.0)
            .style("left", "0px");

        rows.exit()
            .attr('is_new', 'exit')
            .transition("exit_rows")
            .ease(d3.easeQuad) //"quad" d3.v3
            .delay(0)
            .duration(1000)
            .style('opacity', 0.0)
            .style("left", "600px")
            .remove();
    }                   
    function addTriangle() {
        d3.selectAll("[cell_type = pos]").filter("*:not([is_new = exit])")
            .append('svg')
            .attr("class", "triangle")
            .attr("height", triangle_height + "px")
            .attr("width", triangle_width + "px")
                .append('polygon')
                .attr('points', function(d) {
                    var diff = +previousData.get(this) - d.value;  // Retrieve previously stored data.               
                    return diff < 0 ? "0,0 " + triangle_width + ",0 " + triangle_width/2 +"," + triangle_height + " 0,0" : 
                            diff > 0 ? "0," + triangle_height +" " + triangle_height+","+triangle_width+" "+triangle_width/2+",0 0,"+triangle_height :
                            "0," + triangle_height/2 + " " + triangle_width+","+triangle_width/2+" 0," + triangle_width/2;
                    })
                .style("fill" ,function(d) {
                    var diff = +previousData.get(this) - d.value; 
                    return diff < 0 ? "red" : diff > 0 ? "green" : "black";
                    })
                .style("stroke" ,function(d) {
                    var diff = +previousData.get(this) - d.value; 
                    return diff === 0 ? "black" : "";
                    })
                .style("opacity", 0)
                .transition()
                .duration(1000)
                .ease(d3.easeLinear)
                .style("opacity", 1);
    }
    function savePreviousData() {
        d3.selectAll("[cell_type = pos]").each(function(d) { previousData.set(this, d.value) });
    }
    function shuffle(a) {
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
    }
}

function showDetails()
{
    let movingRows = d3.selectAll("div.datarow")
        .filter((d) => d.pos > d3.select(this).datum().pos);

    let movingRowsNodes = movingRows.nodes();

    movingRows.transition()
        .duration(1000)
        .style("top", (d, i) => { return +d3.select(movingRowsNodes[i]).style("top").slice(0,-2) + 30 + "px"});
        //    return (d.pos * row_size + 30) + "px";});
            
            //return +.style("top").slice(0,-2) + 30 +"px";});
}
createToplist(tweets.tweets);
d3.select("#controls").insert("button", ".table").on("click", sortSheet).html("sort")
d3.select("#controls").insert("button", ".table").on("click", transitionSheet).html("transition")
d3.select("#controls").insert("button", ".table").on("click", transformData).html("transform")


redraw();


</script>